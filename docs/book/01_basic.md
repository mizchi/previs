# コード生成: 基本的な考え方

## 分類

コードを生成すると言っても、生成する用途によって

### Function Calling


### プログラマの補助

Copilot 等がそれにあたります。

### ブラックボックス関数

```ts
async function refactorCode(code: string) {
  const newCode = ...;
  return newCode;
}
```


## ゼロショットの幻想を捨てる

まず大前提として、曖昧な自然言語から一発でコードを生成する、いわゆるゼロショットの幻想は捨てるべきです。その上で、一体何をAI(OpenAI)に提供すればコード生成の精度が上がるかを考えていきましょう。

今の生成AIは実質的に穴埋めソルバーです。なので基本的には、生成したい要素の周辺を揃えてから、生成対象を「埋めてもらう」というイメージでコードを生成を指示します。

コード生成においては、基本的に次の3要素を基本的な構成要素として考えています。

- 実装
- ユニットテスト
- コメント(ドキュメント)

ユニットテストについてはなくてもコード生成は可能ですが、事前条件、事後条件を定義しておくことで、それを満たすまで自動的に再生成を行うループを回すことができます。

逆に、実装からテストを生成させると、よほどプロンプトを工夫しないと自明すぎてトートロジーなものになる傾向があります。また、実装からドキュメント(コメント)を生成/挿入させることは可能ですが、これもやや自明すぎて同じくトートロジーになる傾向があります。

これらを踏まえると、AIコード生成で一番勝ちが高い生成パターンは、「事前にテストを用意して、ユーザーの要求を元に、ドキュメントを埋め込んだ実装を生成」というパターンだと自分は考えています。

## In Source Testing

実装、テスト、ドキュメントの3要素は、相互に影響がある一つのソースとして、近接したドキュメントとして存在すると扱いやすくなります。同じコード中に実装とドキュメント(コメント)、そして In-Source Test で実装できると望ましいと自分は考えています。

### TS + Vitest の例

```
// 足し算
export function add(a: number, b: number) {
  return a + b;
}

if (import.meta.vitest) {
  const {test, expect} = import.meta.vitest;
  test('1+2=3', () => {
    expect(add(1, 2)).toBe(3);
  })
}

```

### Rust の例

```
// 足し算
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(4, add(2, 2));
    }
}

```

他にも、Python の doctest なんかもありますね。

In Source Testing によって、実装とテスト双方がお互いを補うプロンプトとして機能しやすくなります。プログラマの好みとして  In Source Testing に対して好き嫌いがあるのは知っていますが、少なくともAIに渡すコードとしてはこれがもっとも扱いやすいフォーマットだと自分は考えます。

注意点として、実装/テスト/コメントのうち、1つしかない状態で、2つ以上を生成すると、今のAIの性能では過学習に陥ります。自分が生成したコードの自己バイアスによって間違ってる状態が強化されてしまうので、やはりいずれかの段階でプログラマによる検証が必要なります。

## 出力構造の指定

実行を前提としたコードを生成する場合、出力構造を規定するプロンプトが必要になります。

- コード以外の出力は不要です。
- 出力するコードには可能な限り変更意図を表現するコメントを残してください
- あなたは TypeScript のコードを生成します。

出力例

```jsx
```tsx
export function xxx(){}
```
```
